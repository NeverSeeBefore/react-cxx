**HOOK**
16.8.0 之后出现的新东西,

- 只能再函数组件中使用
- 本质上是一个函数,可以挂载各种功能,总是以 use 开头

类组件的麻烦:

1. this 指向问题
2. 繁琐的生命周期
3. 其他问题

HOOK 专门用于增强函数组件的功能,使之理论上可以称为类组件的替代品
官方目前并没有计划取消类组件,只是鼓励使用函数组件

HOOK 种类

1. useState
2. useEffect
3. ...

# State Hook

是一个再函数组件中使用的函数,用于再函数组件中使用状态

useState
有一个参数,参数的默认值代表状态的默认值
useState(0); // 使用一个状态,状态的默认值为 0;
// 函数的返回值是一个数组,该数组一定包含两项
const n = arr[0];// 1. 第一项是状态的值
const setN = arr[1];// 2. 改变状态的方法
const [n, setN] = useState(0) // 常用写法

_优点_
一个函数组件中可以有多个状态,非常利于横向切割关注点;

# State Hook 原理

如果第一次生成节点，会生成一个状态表格。
调用第 N 个 useState，检查表格下标为 N 的位置有没有内容：
如果表格没有内容，会使用默认值创建一个状态，并将状态加入表格;
如果有内容，会忽略默认值。

_注意点_

1. 状态最好写到函数的起始位置；（便于阅读）
2. useState 严禁出现再代码块中；（循环，判断）
3. useState 的返回函数，_引用不变_；（第二个参数引用不变，节省空间）
4. 如果使用函数改变数据，若数据和之前的数据完全相等，不会重新渲染;（Object.is 判断， 优化效率）
5. 使用函数改变数据，传入的值不会和原来的数据进行合并，而是*直接替换*;（官方建议多个属性时，设置多个状态）
6. 如果要实现*强制刷新组件*
7. 类组件：this.forceUpdate();(不会运行 shouldComponentUpdate)
8. 函数组件： 使用一个空对象 useState
9. 如果某些状态见没有必然联系，应该*分化为不同的状态*，而不是合并为一个对象；
10. 和类组件一样，函数组件中改变状态可能时*异步*的，多个改变状态会合并，此时不能*信任*；
    解决办法： setN(prevN => prevN + 1); setN(prevN => prevN + 1)

# Effect Hook

副作用

1. ajax 请求
2. 计时器
3. 其他异步请求
4. 更改真实 DOM
5. 本地存储
6. 其他会对外部产生影响的草错

## useEffect

接收一个函数作为参数，再其中执行副作用操作

_注意_

1. 执行时间点为页面真实的 UI*渲染完毕*，不会阻塞浏览器，它的执行时异步的

- 与类组件中 componentDidMount 和 componentDidUpdate 的区别
  1. componentDidMount 和 componentDidUpdate 更改了真实 DOM，但用户还*没看到 UI 更新*，因为浏览器还没有重绘/重构
  2. EffectHook 实在页面*重新渲染*之后才执行

2. 每个函数组件中，可以多次使用 useEffect，但*不要*放在判断或循环等代码块中
3. useEffect 可以有返回值，返回值必须时一个函数，叫做清理函数

- 首次加载不会运行
- 除了首次加载，渲染函数 --》 清理函数 --》 副作用函数
- 组件卸载后， 会运行清理函数

4. useEffect 可以传第二个参数

- _第二个参数是一个数组_
- 数组中记录副作用的依赖数据
- 当组件重新渲染后,只有依赖数据与上一次不一样时,才会执行副作用
- 所以,传递了依赖数据后,如果数据一直不变化
  1. 副作用函数只会再首次渲染执行
  2. 清理函数只在卸载组件后运行

5. 副作函数中,如果使用了函数上下文的变量,则由于闭包的影响,会导致副作用函数中,变量实时变化;
6. 副作用函数每次注册时,会*覆盖*掉之前的副作用函数,因此应尽量保持副作用函数稳定,否则控制起来会比较复杂

# 自定义 HOOK

类似 高阶组件、 renderProps

有一些常用的、跨越多个组件的 HOOK 功能，抽离出去形成一个函数，该函数就是自定义 HOOK
由于器内部需要使用 HOOK 功能，所以本身也需要按照 HOOK 的规则实现：

1. 函数名 use 开头
2. 调用时放到顶层

例如

1. 很多组件都需要再第一次加载完成后，获取所有学生列表
2. 都需要再第一次加载完成之后启动计时器

# Reducer Hook

**Flux**: Facebook 出品的一个数据流框架

1. 规定了数据是*单向*流动的
2. 数据存储在*数据仓库*中(目前可以认为 state 就是存储数据的仓库)
3. action 是改变的*唯一原因*（任何数据的变化都应该有 action 来触发）

- _type_: 字符串，动作的类型（增删改查）
- _payload_： 任意类型，动作发生后的附加信息
- 添加一个学生时 action 可以是这样的：{type: 'addStudent', payload: {学生的各种信息}

4. 具体改变数据的是一个函数，改函数叫做*reducer*

- 该函数接受*两个参数*
  1. _state_: 表示当前数据仓库中的数据
  2. _action_: 描述如何改变数据，以及改变数据的一些附加信息
- 该函数*必须*有返回结果
  1. 表示数据仓库变化之后的结果
  2. flux 要求， _对象不可变_，如果返回对象，必须创建新对象

5. 如果要触发 reducer，不可以直接调用，应该调用辅助函数 dispatch

- 只接受一个*参数*：action
- 该函数会间接*调用 reducer*，以达到改变数据的目的
- 必须是纯函数，不能有任何副作用

官方提供了**useReducer**
第一个参数： reducer
第二个参数： 状态默认值
第三个参数： 函数,返回结果会作为*初始值*(如果传了第三个参数,会将第二个参数传入该函数,返回结果会作为默认值)

# Context Hook

获取上下文
var ctx = React.createContext();
var context = useContext(ctx)

# CallBack Hook

useCallBack
得到固定引用值的函数，通常用于性能优化
_参数_

1. 函数， useCallBack 会固定改函数，只要依赖项没有变化，则返回相对固定的函数地址
2. 数组， 依赖项

_返回值_
相对固定的函数地址

# Memo Hook

用于保持哪些需要高开销的计算才能得到的值
用于保持一些比较稳定的数据
通常用于*性能优化*

```js
  // 第一次运行,会将第一个参数执行的返回结果当作自己的返回结果，
  // 第二次，如果依赖项没有变化，不会运行第一个参数，直接返回上次运行返回的结果
  const handleClick = useMemo(() => {
    return () => setTxt(txt + 1);
  }, [txt])
  // 与useCallBack的区别就是
  // useCallBack返回的是函数，而useMemo返回的是结果
```
useMemo更加*通用*，
因为 useCallBack只能固定函数，useMemo任意

# Ref Hook

useRef 
参数  (默认值)
返回  固定对象 {current: 值} 

createRef每次创建都是全新的

# ImperativeHandle Hook

useImperativeHandle(ref, () => {return ref.current}, [])
参数： 
1. ref
2. 函数，返回值作为ref.current
3. [], 依赖项，(不传依赖项时，每次渲染都会执行；传了依赖项，第一次运行执行，之后只有依赖项变化时执行)

# LayoutEffectHook

16.66666ms浏览器刷新

useEffect: 浏览器刷新完成，用户看到渲染效果之后才会运行
useLayoutEffect: 渲染之前

# DebugValue Hook

useDebugValue
用于将自定义HOOk的关联数据显示到调试栏

写在自定义组件中

