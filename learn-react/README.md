**HOOK**
16.8.0之后出现的新东西,
  - 只能再函数组件中使用
  - 本质上是一个函数,可以挂载各种功能,总是以use开头

类组件的麻烦: 
1. this指向问题
2. 繁琐的生命周期
3. 其他问题

HOOK专门用于增强函数组件的功能,使之理论上可以称为类组件的替代品
官方目前并没有计划取消类组件,只是鼓励使用函数组件

HOOK种类
1. useState
2. useEffect
3. ...

# State Hook
  是一个再函数组件中使用的函数,用于再函数组件中使用状态

  useState
  有一个参数,参数的默认值代表状态的默认值
  useState(0);  // 使用一个状态,状态的默认值为0;
                // 函数的返回值是一个数组,该数组一定包含两项
const n = arr[0];// 1. 第一项是状态的值
const setN = arr[1];// 2. 改变状态的方法
const [n, setN] = useState(0) // 常用写法

*优点*
一个函数组件中可以有多个状态,非常利于横向切割关注点;

# State Hook原理
如果第一次生成节点，会生成一个状态表格。
调用第N个useState，检查表格下标为N的位置有没有内容：
如果表格没有内容，会使用默认值创建一个状态，并将状态加入表格;
如果有内容，会忽略默认值。

*注意点*
1. 状态最好写到函数的起始位置；（便于阅读）
2. useState严禁出现再代码块中；（循环，判断）
3. useState的返回函数，*引用不变*；（第二个参数引用不变，节省空间）
4. 如果使用函数改变数据，若数据和之前的数据完全相等，不会重新渲染;（Object.is判断， 优化效率）
5. 使用函数改变数据，传入的值不会和原来的数据进行合并，而是*直接替换*;（官方建议多个属性时，设置多个状态）
6. 如果要实现*强制刷新组件*
  1. 类组件：this.forceUpdate();(不会运行shouldComponentUpdate)
  2. 函数组件： 使用一个空对象useState
7. 如果某些状态见没有必然联系，应该*分化为不同的状态*，而不是合并为一个对象；
7. 和类组件一样，函数组件中改变状态可能时*异步*的，多个改变状态会合并，此时不能*信任*；
  解决办法： setN(prevN => prevN + 1); setN(prevN => prevN + 1)

# Effect Hook
副作用
1. ajax请求
2. 计时器
3. 其他异步请求
4. 更改真实DOM
5. 本地存储
6. 其他会对外部产生影响的草错

## useEffect
接收一个函数作为参数，再其中执行副作用操作

*注意*
1. 执行时间点为页面真实的UI*渲染完毕*，不会阻塞浏览器，它的执行时异步的
  - 与类组件中componentDidMount和componentDidUpdate的区别
    1. componentDidMount和componentDidUpdate 更改了真实DOM，但用户还*没看到UI更新*，因为浏览器还没有重绘/重构
    2. EffectHook实在页面*重新渲染*之后才执行
2. 每个函数组件中，可以多次使用useEffect，但*不要*放在判断或循环等代码块中
3. useEffect可以有返回值，返回值必须时一个函数，叫做清理函数
  - 首次加载不会运行
  - 除了首次加载，渲染函数 --》 清理函数 --》 副作用函数
  - 组件卸载后， 会运行清理函数
4. useEffect可以传第二个参数
  - *第二个参数是一个数组*
  - 数组中记录副作用的依赖数据
  - 当组件重新渲染后,只有依赖数据与上一次不一样时,才会执行副作用
  - 所以,传递了依赖数据后,如果数据一直不变化
      1. 副作用函数只会再首次渲染执行
      2. 清理函数只在卸载组件后运行
5. 副作函数中,如果使用了函数上下文的变量,则由于闭包的影响,会导致副作用函数中,变量实时变化;
6. 副作用函数每次注册时,会*覆盖*掉之前的副作用函数,因此应尽量保持副作用函数稳定,否则控制起来会比较复杂

# 自定义HOOK

类似 高阶组件、 renderProps

有一些常用的、跨越多个组件的HOOK功能，抽离出去形成一个函数，该函数就是自定义 HOOK
由于器内部需要使用HOOK功能，所以本身也需要按照HOOK的规则实现：
1. 函数名use开头
2. 调用时放到顶层

例如
1. 很多组件都需要再第一次加载完成后，获取所有学生列表
2. 都需要再第一次加载完成之后启动计时器