**HOOK**
16.8.0之后出现的新东西,
  - 只能再函数组件中使用
  - 本质上是一个函数,可以挂载各种功能,总是以use开头

类组件的麻烦: 
1. this指向问题
2. 繁琐的生命周期
3. 其他问题

HOOK专门用于增强函数组件的功能,使之理论上可以称为类组件的替代品
官方目前并没有计划取消类组件,只是鼓励使用函数组件

HOOK种类
1. useState
2. useEffect
3. ...

# State Hook
  是一个再函数组件中使用的函数,用于再函数组件中使用状态

  useState
  有一个参数,参数的默认值代表状态的默认值
  useState(0);  // 使用一个状态,状态的默认值为0;
                // 函数的返回值是一个数组,该数组一定包含两项
const n = arr[0];// 1. 第一项是状态的值
const setN = arr[1];// 2. 改变状态的方法
const [n, setN] = useState(0) // 常用写法

*优点*
一个函数组件中可以有多个状态,非常利于横向切割关注点;

# State Hook原理
如果第一次生成节点，会生成一个状态表格。
调用第N个useState，检查表格下标为N的位置有没有内容：
如果表格没有内容，会使用默认值创建一个状态，并将状态加入表格;
如果有内容，会忽略默认值。

*注意点*
1. 状态最好写到函数的起始位置；（便于阅读）
2. useState严禁出现再代码块中；（循环，判断）
3. useState的返回函数，*引用不变*；（第二个参数引用不变，节省空间）
4. 如果使用函数改变数据，若数据和之前的数据完全相等，不会重新渲染;（Object.is判断， 优化效率）
5. 使用函数改变数据，传入的值不会和原来的数据进行合并，而是*直接替换*;（官方建议多个属性时，设置多个状态）
6. 如果要实现*强制刷新组件*
  1. 类组件：this.forceUpdate();(不会运行shouldComponentUpdate)
  2. 函数组件： 使用一个空对象useState
7. 如果某些状态见没有必然联系，应该*分化为不同的状态*，而不是合并为一个对象；
7. 和类组件一样，函数组件中改变状态可能时*异步*的，多个改变状态会合并，此时不能*信任*；
  解决办法： setN(prevN => prevN + 1); setN(prevN => prevN + 1)
